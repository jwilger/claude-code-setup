//! TUI Rendering with Hexagonal Architecture
//! Separates rendering logic from terminal backend for testability

use ratatui::{
    backend::Backend,
    layout::{Constraint, Direction, Layout},
    style::{Color, Style},
    widgets::{Block, Borders, Paragraph},
    Frame, Terminal,
};
use crate::{SessionHandle, AppResult};

/// Trait for rendering session state to a backend
/// This is the "port" in hexagonal architecture
pub trait Renderer {
    /// Render the current session state
    /// Takes immutable reference - no mutation of state
    fn render<F, B>(&mut self, session: &SessionHandle<F, B>) -> AppResult<()>;
}

/// Terminal-based renderer implementation
/// This is an "adapter" in hexagonal architecture
pub struct TuiRenderer<B: Backend> {
    terminal: Terminal<B>,
}

impl<B: Backend> TuiRenderer<B> {
    /// Create a new TUI renderer with the given backend
    pub fn new(backend: B) -> AppResult<Self> {
        let terminal = Terminal::new(backend)?;
        Ok(TuiRenderer { terminal })
    }

    /// Get reference to the terminal (for testing)
    pub fn terminal(&self) -> &Terminal<B> {
        &self.terminal
    }

    /// Get mutable reference to terminal (for setup)
    pub fn terminal_mut(&mut self) -> &mut Terminal<B> {
        &mut self.terminal
    }
}

/// Rendering implementation for any session state
impl<B: Backend> Renderer for TuiRenderer<B> {
    fn render<F, BS>(&mut self, session: &SessionHandle<F, BS>) -> AppResult<()> {
        self.terminal.draw(|frame| {
            render_session_to_frame(session, frame);
        })?;
        Ok(())
    }
}

/// Render session state to a ratatui Frame
fn render_session_to_frame<F, B>(session: &SessionHandle<F, B>, frame: &mut Frame) {
    let chunks = Layout::default()
        .direction(Direction::Vertical)
        .constraints([
            Constraint::Min(3),      // Message history
            Constraint::Length(3),   // Input buffer
        ])
        .split(frame.area());

    // Render message history pane
    let messages = Paragraph::new("Message history will appear here")
        .block(Block::default()
            .title("Messages")
            .borders(Borders::ALL));
    frame.render_widget(messages, chunks[0]);

    // Render input buffer pane
    let buffer_content = session.get_input_buffer()
        .unwrap_or_else(|_| String::new());

    let input = Paragraph::new(buffer_content)
        .block(Block::default()
            .title("Input")
            .borders(Borders::ALL)
            .border_style(Style::default().fg(Color::Yellow)));
    frame.render_widget(input, chunks[1]);
}

#[cfg(test)]
mod tests {
    use super::*;
    use ratatui::backend::TestBackend;
    use crate::{start_tui_session, ApplicationConfig};

    #[tokio::test]
    async fn test_rendering_with_test_backend() {
        // Create test backend
        let backend = TestBackend::new(80, 24);
        let mut renderer = TuiRenderer::new(backend)
            .expect("Should create renderer");

        // Create session with some text
        let session = start_tui_session(ApplicationConfig::default())
            .await
            .expect("Should start session");
        let session = session.send_text_input("Hello, World!")
            .expect("Should add text");

        // Render the session
        renderer.render(&session)
            .expect("Should render");

        // Check the rendered output
        let buffer = renderer.terminal().backend().buffer();
        let output = buffer.content.iter()
            .map(|c| c.symbol())
            .collect::<String>();

        // Verify text appears in rendered output
        assert!(output.contains("Hello, World!"),
            "Rendered output should contain input text");
        assert!(output.contains("Input"),
            "Should show input pane title");
        assert!(output.contains("Messages"),
            "Should show message pane title");
    }
}