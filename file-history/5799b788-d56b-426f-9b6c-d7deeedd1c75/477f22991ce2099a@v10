//! Integration Test: TUI Session Startup
//!
//! Tests the fundamental workflow functions for TUI chat session lifecycle.
//! This follows the WORKFLOW FUNCTIONS FIRST approach - we test the functions
//! we WISH existed and let compiler errors drive minimal type creation.

use cli_client::{ApplicationConfig, start_tui_session};

#[tokio::test]
async fn test_start_tui_session_succeeds_with_valid_config() {
    // WORKFLOW FUNCTION TEST: Test the function we WISH existed
    // TARGET: US-001, FR-1.1 - Multi-pane TUI with message history
    // APPROACH: Assume start_tui_session() exists, let compiler tell us what's missing
    // EXPECTED FAILURE: Compilation error - function doesn't exist in lib.rs

    // Arrange: Create valid configuration using existing domain type
    let config = ApplicationConfig::default();

    // Act: Call the workflow function we WISH existed
    // This will drive implementation through compiler errors
    let result = start_tui_session(config).await;

    // Assert: Single assertion driving implementation forward
    // Once function exists with unimplemented!(), this will fail at runtime
    // That's when we know to implement the actual behavior
    assert!(
        result.is_ok(),
        "TUI session should start successfully with valid configuration"
    );
}

#[tokio::test]
async fn test_can_type_text_into_input_buffer() {
    // BLACK-BOX USER BEHAVIOR TEST: Test observable user interaction
    // TARGET: US-003, FR-1.2 - Multi-line input editor captures user text
    // APPROACH: Test USER ACTION (typing) and OBSERVABLE STATE (buffer content)
    // NOT TESTING: Internal layout structure, panes, TUI framework details
    // EXPECTED FAILURE: Compilation error - workflow functions don't exist

    // Arrange: Start a TUI session using existing passing workflow function
    let config = ApplicationConfig::default();
    let session = start_tui_session(config)
        .await
        .expect("Session should start successfully");

    // Act: User types "Hello" into the input buffer
    // This simulates the user action of typing text
    let session = session.send_text_input("Hello");

    // Assert: The input buffer contains the text the user typed
    // This tests what the user can OBSERVE - their typed text appears
    let buffer = session
        .get_input_buffer()
        .expect("Should be able to retrieve input buffer");

    assert_eq!(
        buffer, "Hello",
        "Input buffer should contain the text user typed"
    );
}

#[tokio::test]
async fn test_tab_key_changes_input_focus() {
    // BLACK-BOX BEHAVIOR TEST: Tab key cycles focus and compiler enforces state-specific operations
    // TARGET: US-001, FR-1.3 - Navigation between panes with Tab key
    // TYPESTATE ENFORCEMENT: Compiler prevents send_text_input when HistoryFocused
    // NOTE: Original test tried to verify text doesn't append after Tab - now compiler prevents it entirely

    // Arrange: Start TUI session (InputFocused by default)
    let config = ApplicationConfig::default();
    let session = start_tui_session(config)
        .await
        .expect("Session should start successfully");

    // Act Part 1: Type text with initial focus
    let session = session.send_text_input("Before");

    // Act Part 2: Press Tab to move to HistoryFocused
    let session = session.press_tab();
    // NOTE: Can't call send_text_input here - compiler prevents it (typestate enforcement)

    // Act Part 3: Press Tab again to return to InputFocused
    let session = session.press_tab();

    // Act Part 4: Type more text now that we're back at InputFocused
    let session = session.send_text_input(" After");

    // Assert: Both texts present, proving Tab cycling works and preserves state
    let buffer = session
        .get_input_buffer()
        .expect("Should be able to retrieve input buffer");

    assert_eq!(
        buffer, "Before After",
        "Tab cycling should preserve buffer state while preventing text input during HistoryFocused"
    );
}

#[tokio::test]
async fn test_enter_key_clears_input_buffer() {
    // BLACK-BOX BEHAVIOR TEST: Enter key clears the input buffer
    // TARGET: US-003 - Multi-line input editor with Enter to send
    // SINGLE ASSERTION: Input buffer empty after pressing Enter
    // NOTE: Actual message sending to backend verified in separate test

    // Arrange: Start TUI session and type a message
    let config = ApplicationConfig::default();
    let session = start_tui_session(config)
        .await
        .expect("Session should start successfully");

    let session = session.send_text_input("Hello, chat service!");

    // Act: Press Enter to submit
    let session = session.press_enter()
        .await
        .expect("Should be able to press Enter");

    // Assert: Input buffer cleared
    let buffer = session
        .get_input_buffer()
        .expect("Should be able to retrieve input buffer");

    assert_eq!(
        buffer, "",
        "Input buffer should be cleared after pressing Enter"
    );
}
