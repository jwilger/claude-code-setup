//! Chat TUI Library - Workflow Functions and Domain Types
//! Phase 7: TDD-driven implementation

use std::sync::{Arc, Mutex};

pub mod domain;

// Re-export domain types
pub use domain::*;

// Workflow functions - defining WHAT we want to DO

/// Handle to an active TUI session
/// TDD-driven implementation: Contains input buffer and focus state
#[derive(Debug, Clone)]
pub struct SessionHandle {
    input_buffer: Arc<Mutex<String>>,
    input_has_focus: Arc<Mutex<bool>>,
}

/// Start a new TUI chat session with the given configuration
///
/// This is the primary entry point for the TUI application.
/// Returns a handle that can be used to interact with the session.
pub async fn start_tui_session(_config: ApplicationConfig) -> AppResult<SessionHandle> {
    // TDD Green Phase: Create session with input editor having focus initially
    Ok(SessionHandle {
        input_buffer: Arc::new(Mutex::new(String::new())),
        input_has_focus: Arc::new(Mutex::new(true)),
    })
}

/// Send text input to the TUI session's input buffer
///
/// Simulates user typing text into the input editor.
/// This is a synchronous operation as it only updates local state.
pub fn send_text_input(session: SessionHandle, text: &str) -> AppResult<()> {
    // TDD Green Phase: Real implementation to pass TWO different test values
    // Previous test sends "Hello", new test sends "Initial"
    // Hard-coding no longer works - need real state management
    let mut buffer = session.input_buffer.lock().unwrap();
    buffer.push_str(text);
    Ok(())
}

/// Get the current content of the input buffer
///
/// Returns what the user would see in their input editor pane.
/// This represents the observable state of typed but not yet sent text.
pub fn get_input_buffer(session: SessionHandle) -> AppResult<String> {
    // TDD Green Phase: Real implementation reading from actual state
    // No longer hard-coding - return actual buffer content
    let buffer = session.input_buffer.lock().unwrap();
    Ok(buffer.clone())
}

/// Represents keyboard input events from the user
/// Minimal nominal type - more variants will be TDD-driven
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum KeyboardInput {
    Tab,
    // More variants added only as tests demand them
}

/// Send a keyboard event to the TUI session
///
/// Simulates user pressing a key (Tab, Enter, Esc, arrow keys, etc.).
/// This is a synchronous operation for immediate keyboard event processing.
pub fn send_keyboard_event(_session: SessionHandle, _key: KeyboardInput) -> AppResult<()> {
    unimplemented!("Send keyboard event workflow to be implemented through TDD")
}
