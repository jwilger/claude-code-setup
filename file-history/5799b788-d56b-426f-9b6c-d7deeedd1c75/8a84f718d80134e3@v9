//! Chat TUI Library - Workflow Functions and Domain Types
//! Phase 7: TDD-driven implementation with immutable typestate pattern

use nutype::nutype;
use std::marker::PhantomData;

pub mod domain;

// Re-export domain types
pub use domain::*;

// ==== DOMAIN TYPES ====

/// Input buffer content - eliminates primitive obsession
#[nutype(derive(Debug, Clone, PartialEq, Eq))]
pub struct InputBuffer(String);

// ==== IMMUTABLE TYPESTATE PATTERN: Zero-cost focus state tracking ====

/// Marker type indicating input editor has focus
#[derive(Debug)]
pub struct InputFocused;

/// Marker type indicating history pane has focus
#[derive(Debug)]
pub struct HistoryFocused;

/// Handle to an active TUI session with compile-time focus state
/// Immutable by design - all operations consume self and return new instances
#[derive(Debug, Clone)]
pub struct SessionHandle<State> {
    input_buffer: InputBuffer,
    _state: PhantomData<State>,
}

// ==== WORKFLOW FUNCTIONS ====

/// Start a new TUI chat session with the given configuration
///
/// Returns a SessionHandle<InputFocused> as input editor has focus by default
pub async fn start_tui_session(
    _config: ApplicationConfig,
) -> AppResult<SessionHandle<InputFocused>> {
    Ok(SessionHandle {
        input_buffer: InputBuffer::new(String::new()),
        _state: PhantomData,
    })
}

// ==== STATE-SPECIFIC IMPLEMENTATIONS ====

// Methods only available when input has focus
impl SessionHandle<InputFocused> {
    /// Send text to the input buffer (only works when input has focus)
    /// Consumes self and returns new instance with updated buffer
    pub fn send_text_input(self, text: &str) -> SessionHandle<InputFocused> {
        let current = self.input_buffer.into_inner();
        SessionHandle {
            input_buffer: InputBuffer::new(format!("{}{}", current, text)),
            _state: PhantomData,
        }
    }

    /// Press Tab to move focus to history pane
    /// Consumes self and returns new type - old handle cannot be used
    pub fn press_tab(self) -> SessionHandle<HistoryFocused> {
        SessionHandle {
            input_buffer: self.input_buffer,
            _state: PhantomData,
        }
    }
}

// Methods only available when history has focus
impl SessionHandle<HistoryFocused> {
    /// Press Tab to cycle focus back to input editor
    pub fn press_tab(self) -> SessionHandle<InputFocused> {
        SessionHandle {
            input_buffer: self.input_buffer,
            _state: PhantomData,
        }
    }
}

// ==== SHARED OPERATIONS (available in any focus state) ====

impl<State> SessionHandle<State> {
    /// Get the current input buffer content (readable from any focus state)
    pub fn get_input_buffer(&self) -> AppResult<String> {
        Ok(self.input_buffer.clone().into_inner())
    }
}

/// Keyboard input events
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum KeyboardInput {
    Tab,
    // More variants as tests demand
}

/// Send keyboard event - currently unimplemented
pub fn send_keyboard_event<State>(
    _session: SessionHandle<State>,
    _key: KeyboardInput,
) -> AppResult<()> {
    unimplemented!("Keyboard event handling to be driven by tests")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_press_tab_transitions_state_preserving_shared_data() {
        // UNIT TEST: State transition behavior - press_tab consumes handle and returns new type
        // DRIVES: Immutable typestate pattern for focus management
        // SINGLE ASSERTION: After Tab, can still access shared buffer state from new handle type

        // Arrange: Create session (InputFocused by default) and add text
        let session = start_tui_session(ApplicationConfig::default())
            .await
            .expect("Session should start");

        let session = session.send_text_input("BeforeTab");

        // Act: Press Tab to transition state (consumes InputFocused, returns different type)
        let session_after_tab = session.press_tab();

        // Assert: New handle can still access the same underlying buffer state
        let buffer = session_after_tab
            .get_input_buffer()
            .expect("Should retrieve buffer from new state");
        assert_eq!(
            buffer, "BeforeTab",
            "After state transition, new handle should still access same shared buffer state"
        );
    }
}